<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D å®ˆå¡”ä¿è¡›æˆ° (Tower Defense)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* HUD ä»‹é¢ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-bar {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 1.2rem;
            font-weight: bold;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            border-bottom: 2px solid #666;
        }

        .stat-box span {
            color: #ffd700;
            font-size: 1.4rem;
        }

        #bottom-bar {
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
        }

        .tower-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid #ccc;
            border-radius: 10px;
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 110px;
        }

        .tower-btn:hover {
            transform: translateY(-5px);
            background: #fff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .tower-btn.selected {
            border-color: #00ff00;
            background: #e6ffe6;
            box-shadow: 0 0 20px #00ff00;
        }

        .tower-btn h4 {
            margin: 5px 0;
            color: #333;
            font-size: 1rem;
        }

        .tower-btn p {
            margin: 0;
            color: #d32f2f;
            font-weight: bold;
        }
        
        .tower-hp {
            font-size: 0.8rem;
            color: #666;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            text-align: center;
            border-radius: 20px;
            display: none;
            pointer-events: auto;
            border: 2px solid #ff4444;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            z-index: 10;
        }

        #game-over h1 {
            color: #ff4444;
            font-size: 3rem;
            margin-top: 0;
        }

        button.restart-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }

        button.restart-btn:hover {
            background: #ff6666;
        }

        .color-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-bottom: 5px;
            border: 1px solid #999;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <div id="top-bar">
            <div class="stat-box">â¤ï¸ ç”Ÿå‘½: <span id="lives-display">20</span></div>
            <div class="stat-box">ğŸ’° é‡‘å¹£: <span id="money-display">1000</span></div>
            <div class="stat-box">ğŸŒŠ æ³¢æ•¸: <span id="wave-display">1</span></div>
            <div class="stat-box">ğŸ‘¾ æ•µäºº: <span id="enemy-count-display">0</span></div>
        </div>

        <div id="bottom-bar">
            <div class="tower-btn selected" onclick="selectTowerType('basic')" id="btn-basic">
                <div class="color-dot" style="background-color: #3498db;"></div>
                <h4>æ©Ÿæ§å¡”</h4>
                <p>$50</p>
                <span class="tower-hp">HP: 100</span>
            </div>
            <div class="tower-btn" onclick="selectTowerType('sniper')" id="btn-sniper">
                <div class="color-dot" style="background-color: #f1c40f;"></div>
                <h4>ç‹™æ“Šå¡”</h4>
                <p>$120</p>
                <span class="tower-hp">HP: 80</span>
            </div>
            <div class="tower-btn" onclick="selectTowerType('laser')" id="btn-laser">
                <div class="color-dot" style="background-color: #9b59b6;"></div>
                <h4>é›·å°„å¡”</h4>
                <p>$200</p>
                <span class="tower-hp">HP: 150</span>
            </div>
        </div>
    </div>

    <div id="game-over">
        <h1>éŠæˆ²çµæŸ</h1>
        <p>æœ€çµ‚æ³¢æ•¸: <span id="final-wave">1</span></p>
        <button class="restart-btn" onclick="restartGame()">é‡æ–°é–‹å§‹</button>
    </div>
</div>

<script>
    // --- éŠæˆ²å¸¸æ•¸ ---
    const TILE_SIZE = 10;
    const GRID_WIDTH = 16;
    const GRID_HEIGHT = 10;
    
    // éŠæˆ²ç‹€æ…‹
    let state = {
        money: 1000,
        lives: 20,
        wave: 1,
        isGameOver: false,
        selectedTowerType: 'basic',
        enemies: [],
        towers: [],
        projectiles: [],
        particles: [],
        path: [] 
    };

    const TOWER_TYPES = {
        'basic': { price: 50, range: 35, damage: 20, color: 0x3498db, cooldown: 30, height: 8, maxHp: 100 },
        'sniper': { price: 120, range: 70, damage: 100, color: 0xf1c40f, cooldown: 90, height: 12, maxHp: 80 },
        'laser': { price: 200, range: 45, damage: 5, color: 0x9b59b6, cooldown: 5, height: 10, maxHp: 150 }
    };

    let scene, camera, renderer, raycaster, mouse;
    let gridMeshes = []; 
    // åœ°å½¢é«˜åº¦åœ– (r, c)
    let terrainHeights = [];

    // --- åˆå§‹åŒ– ---
    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // å¤©ç©ºè—
        scene.fog = new THREE.Fog(0x87CEEB, 50, 300);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 140, 120); 
        camera.lookAt(0, 0, 10);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0); 
        dirLight.position.set(60, 120, 40);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        // æ“´å¤§é™°å½±ç¯„åœä»¥æ¶µè“‹åœ°å½¢
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('pointerdown', onDocumentMouseDown, false);

        createMap();
        animate();
        startWave();
    }

    // --- åœ°åœ–ç”Ÿæˆ (åœ°å½¢èˆ‡è·¯å¾‘) ---
    // 0: è‰åœ°, 1: è·¯å¾‘
    const mapLayout = [
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0],
        [0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0],
        [0,0,0,1,1,1,1,0,0,0,0,0,1,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0,0,1,0,0,0],
        [0,0,1,0,0,0,0,0,1,0,0,0,1,1,1,1],
        [0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];

    function createMap() {
        // 1. ç”Ÿæˆåœ°å½¢é«˜åº¦
        // ç°¡å–®è¦å‰‡ï¼š
        // è·¯å¾‘åŸºæœ¬ä¸Šè¦å¹³ç·©ä¸€äº›ï¼Œä½†å¯ä»¥æœ‰å°å¡åº¦
        // è‰åœ°éš¨æ©Ÿèµ·ä¼ï¼Œå‘¨åœå¯ä»¥æ˜¯å±±ä¸˜(é«˜)æˆ–å‡¹åœ°(ä½)
        
        terrainHeights = [];
        for(let r=0; r<GRID_HEIGHT; r++) {
            let row = [];
            for(let c=0; c<GRID_WIDTH; c++) {
                let h = 0;
                
                // ç°¡å–®çš„é«˜åº¦å™ªè²æ¨¡æ“¬
                const distFromCenter = Math.sqrt(Math.pow(r - GRID_HEIGHT/2, 2) + Math.pow(c - GRID_WIDTH/2, 2));
                
                if (mapLayout[r][c] === 1) {
                    // è·¯å¾‘ï¼šç¨å¾®æœ‰é»å¡åº¦ï¼Œä¾‹å¦‚ä¸­é–“éš†èµ·
                    h = Math.sin(c * 0.5) * 4; // -4 åˆ° 4
                } else {
                    // è‰åœ°ï¼šèµ·ä¼è¼ƒå¤§
                    // éš¨æ©Ÿ + é‚Šç·£å±±è„ˆ
                    h = (Math.random() * 6 - 3) + (distFromCenter > 5 ? 5 : 0);
                    // å¶çˆ¾æœ‰æ·±å‘
                    if (Math.random() < 0.05) h -= 8;
                }
                
                // è®“é«˜åº¦å°é½Šåˆ°æ•´æ•¸æˆ–åŠæ•´æ•¸ï¼Œæ¯”è¼ƒå¥½çœ‹
                h = Math.round(h);
                row.push(h);
            }
            terrainHeights.push(row);
        }

        // 2. ç”Ÿæˆè·¯å¾‘ç¯€é» (3Dåº§æ¨™)
        const pathIndices = [
            {r:1, c:0}, {r:1, c:3}, {r:3, c:3}, {r:3, c:6}, {r:5, c:6}, {r:5, c:2}, {r:8, c:2}, {r:8, c:8}, {r:5, c:8}, {r:5, c:12}, {r:6, c:12}, {r:6, c:15}
        ];
        
        state.path = pathIndices.map(p => {
            // ç²å–è©²æ ¼çš„é«˜åº¦
            const h = terrainHeights[p.r][p.c];
            return new THREE.Vector3(
                (p.c - GRID_WIDTH/2) * TILE_SIZE + TILE_SIZE/2,
                h + 3, // +3 æ˜¯æ•µäººè…³åº•é«˜åº¦ (å› ç‚ºåœ°æ¿ä¸­å¿ƒæ˜¯ hï¼Œè¡¨é¢æ˜¯ h+10(boxHeight/2) ... ç­‰ç­‰ï¼Œæˆ‘å€‘é‡æ–°å®šç¾©åœ°æ¿ç”Ÿæˆæ–¹å¼)
                (p.r - GRID_HEIGHT/2) * TILE_SIZE + TILE_SIZE/2
            );
        });

        // 3. æ¸²æŸ“åœ°å½¢æ–¹å¡Š
        const grassMat = new THREE.MeshLambertMaterial({ color: 0x7cb342 }); 
        const pathMat = new THREE.MeshLambertMaterial({ color: 0x8d6e63 }); 
        const sideMat = new THREE.MeshLambertMaterial({ color: 0x5d4037 }); // åœŸå£¤é¡è‰²

        for(let r=0; r<GRID_HEIGHT; r++) {
            for(let c=0; c<GRID_WIDTH; c++) {
                const type = mapLayout[r][c];
                const h = terrainHeights[r][c];
                
                // ä½¿ç”¨å¾ˆé«˜çš„é•·æ–¹é«”ä¾†æ¨¡æ“¬åœ°å½¢ï¼Œé¿å…åº•éƒ¨ç©¿å¹«
                // å‡è¨­åŸºæº–é¢ y=0ï¼Œæ–¹å¡Šé«˜åº¦ = 20 (base) + h*2 (scale?)
                // é€™è£¡ç°¡å–®åšï¼šæ–¹å¡Šé«˜åº¦å›ºå®šï¼Œæ”¹è®Š y ä½ç½®
                const boxHeight = 40; 
                const geometry = new THREE.BoxGeometry(TILE_SIZE, boxHeight, TILE_SIZE);
                
                // åªæœ‰é ‚é¢æ˜¯è‰/è·¯ï¼Œå´é¢æ˜¯åœŸ
                const materials = [
                    sideMat, sideMat, // x+, x-
                    type === 1 ? pathMat : grassMat, // y+ (top)
                    sideMat, // y- (bottom)
                    sideMat, sideMat // z+, z-
                ];

                const mesh = new THREE.Mesh(geometry, materials);
                
                // è¨ˆç®—ä½ç½®
                // é ‚éƒ¨è¡¨é¢æ‡‰è©²åœ¨ y = h
                // Mesh ä¸­å¿ƒ y = h - boxHeight/2
                mesh.position.set(
                    (c - GRID_WIDTH/2) * TILE_SIZE + TILE_SIZE/2,
                    h - boxHeight/2,
                    (r - GRID_HEIGHT/2) * TILE_SIZE + TILE_SIZE/2
                );
                
                mesh.receiveShadow = true;
                
                mesh.userData = {
                    type: type === 1 ? 'path' : 'grass',
                    gridX: c,
                    gridY: r,
                    height: h, // è¨˜éŒ„è¡¨é¢é«˜åº¦
                    occupied: false
                };

                scene.add(mesh);
                gridMeshes.push(mesh);
            }
        }
        
        // åº•éƒ¨æ°´å¹³é¢ (æ·±æ·µ)
        const planeGeo = new THREE.PlaneGeometry(500, 500);
        const planeMat = new THREE.MeshBasicMaterial({ color: 0x222222 }); 
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -30;
        scene.add(plane);
    }

    // --- æ•µäººç³»çµ± (å«èµ°è·¯å‹•ç•«) ---
    class Enemy {
        constructor(speed, hp, color) {
            // å»ºç«‹ä¸€å€‹ Group ä¾†è£èº«é«”å’Œè…³
            this.mesh = new THREE.Group();
            
            // 1. èº«é«”
            const bodyGeo = new THREE.BoxGeometry(2.5, 3, 2.5);
            const bodyMat = new THREE.MeshPhongMaterial({ color: color });
            this.body = new THREE.Mesh(bodyGeo, bodyMat);
            this.body.position.y = 2.5; // èº«é«”ä¸­å¿ƒé«˜åº¦
            this.body.castShadow = true;
            this.mesh.add(this.body);

            // 2. é›™è…³
            const legGeo = new THREE.CylinderGeometry(0.6, 0.6, 2.5);
            const legMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            
            this.legL = new THREE.Mesh(legGeo, legMat);
            this.legL.position.set(-0.8, 1.25, 0); // ç›¸å°æ–¼ Group çš„ä½ç½®
            this.mesh.add(this.legL);

            this.legR = new THREE.Mesh(legGeo, legMat);
            this.legR.position.set(0.8, 1.25, 0);
            this.mesh.add(this.legR);
            
            // çœ¼ç› (è£é£¾)
            const eyeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.2);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(-0.6, 0.5, 1.3);
            this.body.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(0.6, 0.5, 1.3);
            this.body.add(eyeR);


            this.pathIndex = 0;
            this.progress = 0; 
            this.speed = speed;
            this.hp = hp;
            this.maxHp = hp;
            this.active = true;
            
            // å‹•ç•«ç‹€æ…‹
            this.walkCycle = 0;

            // æ”»æ“Š AI
            this.state = 'MOVING';
            this.attackTarget = null;
            this.attackRange = 18; 
            this.attackDamage = 2; 
            this.attackCooldown = 0;
            this.attackRate = 10; 

            // åˆå§‹ä½ç½®
            this.mesh.position.copy(state.path[0]);
            scene.add(this.mesh);
        }

        update(delta) {
            if(!this.active) return;

            if(this.attackCooldown > 0) this.attackCooldown--;

            // èµ°è·¯å‹•ç•« (åªè¦æ´»è‘—å°±æ“ºå‹•ï¼Œæ”»æ“Šæ™‚å¯ä»¥åœæˆ–ç¹¼çºŒ)
            if (this.state === 'MOVING') {
                this.walkCycle += delta * this.speed * 0.5;
                // è…³çš„å‰å¾Œæ“ºå‹• (ç¹ X è»¸æ—‹è½‰)
                this.legL.rotation.x = Math.sin(this.walkCycle) * 0.8;
                this.legR.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.8;
                // èº«é«”ç¨å¾®ä¸Šä¸‹èµ·ä¼
                this.body.position.y = 2.5 + Math.abs(Math.sin(this.walkCycle * 2)) * 0.2;
            } else {
                // æ”»æ“Šæ™‚æ¢å¾©ç«™å§¿
                this.legL.rotation.x = THREE.MathUtils.lerp(this.legL.rotation.x, 0, 0.1);
                this.legR.rotation.x = THREE.MathUtils.lerp(this.legR.rotation.x, 0, 0.1);
            }

            // AI é‚è¼¯
            if (this.state === 'MOVING') {
                for(let tower of state.towers) {
                    // æª¢æŸ¥è·é›¢ (è€ƒæ…®é«˜åº¦å·®)
                    if(tower.active && this.mesh.position.distanceTo(tower.mesh.position) < this.attackRange) {
                        this.state = 'ATTACKING';
                        this.attackTarget = tower;
                        break;
                    }
                }
            } else if (this.state === 'ATTACKING') {
                if(!this.attackTarget || !this.attackTarget.active) {
                    this.state = 'MOVING';
                    this.attackTarget = null;
                } else {
                    // é¢å‘ç›®æ¨™
                    this.mesh.lookAt(this.attackTarget.mesh.position);
                    
                    if(this.attackCooldown <= 0) {
                        this.attackTarget.takeDamage(this.attackDamage);
                        this.attackCooldown = this.attackRate;
                        
                        // æ’æ“Šå‹•ç•« (èº«é«”å‰å‚¾)
                        this.body.rotation.x = 0.5;
                        setTimeout(() => { if(this.active) this.body.rotation.x = 0; }, 100);
                    }
                    return; 
                }
            }

            // ç§»å‹•é‚è¼¯
            const targetPos = state.path[this.pathIndex + 1];
            const startPos = state.path[this.pathIndex];
            
            if (!targetPos) {
                this.reachEnd();
                return;
            }

            const dist = startPos.distanceTo(targetPos);
            const step = this.speed * delta;
            this.progress += step / dist;

            if(this.progress >= 1) {
                this.progress = 0;
                this.pathIndex++;
                if(this.pathIndex >= state.path.length - 1) {
                    this.reachEnd();
                    return;
                }
            }

            // è¨ˆç®—æ–°çš„ä½ç½®
            const newPos = new THREE.Vector3().lerpVectors(
                state.path[this.pathIndex], 
                state.path[this.pathIndex+1], 
                this.progress
            );
            
            // é¢å‘ç§»å‹•æ–¹å‘
            this.mesh.lookAt(targetPos); // ç°¡å–®é¢å‘ä¸‹ä¸€å€‹ç¯€é»
            // æ›´å¹³æ»‘çš„é¢å‘ï¼šthis.mesh.lookAt(newPos); ä½† lookAt è‡ªå·±æœƒæŠ–å‹•ï¼Œæš«ç”¨ targetPos

            this.mesh.position.copy(newPos);
        }

        takeDamage(amount) {
            this.hp -= amount;
            this.body.material.emissive.setHex(0xff0000);
            setTimeout(() => {
                if(this.active) this.body.material.emissive.setHex(0x000000);
            }, 50);

            if(this.hp <= 0) {
                this.die();
            }
        }

        die() {
            this.active = false;
            scene.remove(this.mesh);
            state.money += 20;
            updateUI();
            createExplosion(this.mesh.position, this.body.material.color);
        }

        reachEnd() {
            this.active = false;
            scene.remove(this.mesh);
            state.lives--;
            updateUI();
            if(state.lives <= 0) gameOver();
        }
    }

    // --- é˜²ç¦¦å¡”ç³»çµ± ---
    class Tower {
        constructor(mesh, typeName) {
            this.mesh = mesh;
            this.type = TOWER_TYPES[typeName];
            this.cooldown = 0;
            this.active = true;
            this.hp = this.type.maxHp;
            this.maxHp = this.type.maxHp;
            
            this.head = mesh.children[0]; 
        }

        update() {
            if(!this.active) return;
            if(this.cooldown > 0) this.cooldown--;

            let target = null;
            let minDist = this.type.range;

            state.enemies.forEach(enemy => {
                if(enemy.active) {
                    const dist = this.mesh.position.distanceTo(enemy.mesh.position);
                    if(dist < minDist) {
                        minDist = dist;
                        target = enemy;
                    }
                }
            });

            if(target) {
                this.head.lookAt(target.mesh.position);
                if(this.cooldown <= 0) {
                    this.shoot(target);
                    this.cooldown = this.type.cooldown;
                }
            }
        }

        shoot(target) {
            const startPos = new THREE.Vector3();
            this.head.getWorldPosition(startPos);
            // ä¿®æ­£å­å½ˆç™¼å°„é»é«˜åº¦ï¼Œé¿å…æ‰“åˆ°åœ°é¢
            // å·²ç¶“ç”¨äº† getWorldPositionï¼Œæ‰€ä»¥æ˜¯æº–ç¢ºçš„
            
            const bullet = new Projectile(startPos, target, this.type.damage, this.type.color);
            state.projectiles.push(bullet);
        }

        takeDamage(amount) {
            this.hp -= amount;
            this.head.material.emissive.setHex(0xff3333);
            setTimeout(() => {
                if(this.active) this.head.material.emissive.setHex(0x000000);
            }, 100);

            if(this.hp <= 0) {
                this.destroy();
            }
        }

        destroy() {
            this.active = false;
            scene.remove(this.mesh);
            createExplosion(this.mesh.position, 0x555555);
            
            // é‡‹æ”¾åœ°å¡Š
            const pos = this.mesh.position;
            // ç”±æ–¼é«˜åº¦ä¸åŒï¼Œé€™è£¡åªæ¯”å° X å’Œ Z
            gridMeshes.forEach(grid => {
                if(Math.abs(grid.position.x - pos.x) < 1 && Math.abs(grid.position.z - pos.z) < 1) {
                    grid.userData.occupied = false;
                }
            });
        }
    }

    // --- æŠ•å°„ç‰© ---
    class Projectile {
        constructor(startPos, targetEnemy, damage, color) {
            this.geometry = new THREE.BoxGeometry(0.8, 0.8, 2);
            this.material = new THREE.MeshBasicMaterial({ color: color });
            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.position.copy(startPos);
            
            this.target = targetEnemy;
            this.damage = damage;
            this.speed = 120;
            this.active = true;

            scene.add(this.mesh);
        }

        update(delta) {
            if(!this.active) return;
            
            if(!this.target.active) {
                this.destroy();
                return;
            }

            // ç„æº–æ•µäººèº«é«”ä¸­å¿ƒ
            const targetPos = this.target.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
            this.mesh.lookAt(targetPos);
            
            const dist = this.mesh.position.distanceTo(targetPos);
            const moveDist = this.speed * delta;

            if(dist <= moveDist) {
                this.target.takeDamage(this.damage);
                this.destroy();
            } else {
                this.mesh.translateZ(moveDist);
            }
        }

        destroy() {
            this.active = false;
            scene.remove(this.mesh);
        }
    }

    // --- ç‰¹æ•ˆ ---
    class Particle {
        constructor(pos, color) {
            this.mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 1.2, 1.2),
                new THREE.MeshBasicMaterial({color: color, transparent: true})
            );
            this.mesh.position.copy(pos);
            
            this.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 25,
                (Math.random() - 0.5) * 25 + 10,
                (Math.random() - 0.5) * 25
            );
            this.life = 1.0; 
            scene.add(this.mesh);
        }
        
        update(delta) {
            this.velocity.y -= 40 * delta; 
            this.mesh.position.addScaledVector(this.velocity, delta);
            this.mesh.rotation.x += delta * 10;
            
            this.life -= delta * 2.5;
            this.mesh.scale.setScalar(this.life);
            this.mesh.material.opacity = this.life;
        }
        
        isDead() { return this.life <= 0; }
        dispose() { scene.remove(this.mesh); }
    }

    function createExplosion(pos, color) {
        for(let i=0; i<8; i++) {
            state.particles.push(new Particle(pos, color));
        }
    }

    // --- éŠæˆ²å¾ªç’° ---
    let waveTimer = 0;
    let enemiesToSpawn = 0;
    let spawnDelay = 0;

    function startWave() {
        state.wave++;
        enemiesToSpawn = 5 + Math.floor(state.wave * 2);
        updateUI();
    }

    function spawnEnemyLogic(delta) {
        if(enemiesToSpawn > 0) {
            spawnDelay -= delta;
            if(spawnDelay <= 0) {
                const hp = 50 + (state.wave * 25);
                const speed = 20 + (state.wave * 1.5); // ç¨å¾®èª¿æ…¢ä¸€é»é»ï¼Œå› ç‚ºæœ‰åœ°å½¢
                const color = new THREE.Color().setHSL((state.wave * 0.15) % 1, 0.8, 0.5);
                
                state.enemies.push(new Enemy(speed, hp, color));
                enemiesToSpawn--;
                spawnDelay = 0.8; 
                
                document.getElementById('enemy-count-display').innerText = state.enemies.filter(e => e.active).length + enemiesToSpawn;
            }
        } else if (state.enemies.filter(e => e.active).length === 0) {
            waveTimer += delta;
            if(waveTimer > 2) { 
                startWave();
                waveTimer = 0;
            }
        }
        document.getElementById('enemy-count-display').innerText = state.enemies.filter(e => e.active).length + enemiesToSpawn;
    }

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const delta = Math.min(clock.getDelta(), 0.1); 

        if(!state.isGameOver) {
            spawnEnemyLogic(delta);

            state.enemies.forEach(e => e.update(delta));
            state.enemies = state.enemies.filter(e => e.active);

            state.towers.forEach(t => t.update());
            state.towers = state.towers.filter(t => t.active);

            state.projectiles.forEach(p => p.update(delta));
            state.projectiles = state.projectiles.filter(p => p.active);
            
            state.particles.forEach(p => p.update(delta));
            for(let i = state.particles.length - 1; i >= 0; i--) {
                if(state.particles[i].isDead()) {
                    state.particles[i].dispose();
                    state.particles.splice(i, 1);
                }
            }
        }

        renderer.render(scene, camera);
    }

    // --- äº¤äº’ ---
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function selectTowerType(type) {
        state.selectedTowerType = type;
        document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
        document.getElementById('btn-' + type).classList.add('selected');
    }

    function onDocumentMouseDown(event) {
        if(state.isGameOver) return;
        if(event.target.closest('.tower-btn')) return;

        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(gridMeshes);

        if (intersects.length > 0) {
            const object = intersects[0].object;
            const data = object.userData;

            if (data.type === 'grass' && !data.occupied) {
                buildTower(object);
            }
        }
    }

    function buildTower(gridMesh) {
        const typeConfig = TOWER_TYPES[state.selectedTowerType];
        // å¾ gridMesh è®€å–è¡¨é¢é«˜åº¦
        const terrainH = gridMesh.userData.height;

        if(state.money >= typeConfig.price) {
            state.money -= typeConfig.price;
            updateUI();

            const baseGeo = new THREE.BoxGeometry(TILE_SIZE * 0.8, 2, TILE_SIZE * 0.8);
            const baseMat = new THREE.MeshPhongMaterial({ color: 0xdddddd }); 
            const baseMesh = new THREE.Mesh(baseGeo, baseMat);
            
            const headHeight = typeConfig.height;
            const headGeo = new THREE.CylinderGeometry(2, 3, headHeight, 8);
            const headMat = new THREE.MeshPhongMaterial({ color: typeConfig.color });
            const headMesh = new THREE.Mesh(headGeo, headMat);
            headMesh.position.y = headHeight/2 + 1; 
            
            const barrelGeo = new THREE.CylinderGeometry(0.8, 0.8, 6);
            const barrelMesh = new THREE.Mesh(barrelGeo, new THREE.MeshPhongMaterial({color: 0x555555}));
            barrelMesh.rotation.x = Math.PI / 2;
            barrelMesh.position.z = 2;
            barrelMesh.position.y = 2;
            headMesh.add(barrelMesh);

            baseMesh.add(headMesh);

            // æ”¾ç½®åœ¨æ­£ç¢ºçš„é«˜åº¦
            baseMesh.position.set(gridMesh.position.x, terrainH + 1, gridMesh.position.z);
            scene.add(baseMesh);

            createExplosion(baseMesh.position, typeConfig.color);

            gridMesh.userData.occupied = true;
            state.towers.push(new Tower(baseMesh, state.selectedTowerType));
        } else {
            const el = document.getElementById('money-display');
            el.style.color = 'red';
            setTimeout(() => el.style.color = '#ffd700', 500);
        }
    }

    function updateUI() {
        document.getElementById('lives-display').innerText = state.lives;
        document.getElementById('money-display').innerText = state.money;
        document.getElementById('wave-display').innerText = state.wave;
    }

    function gameOver() {
        state.isGameOver = true;
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('final-wave').innerText = state.wave;
    }

    window.restartGame = function() {
        location.reload();
    };

    init();
</script>
</body>
</html>
