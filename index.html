<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ÂÆàÂ°î‰øùË°õÊà∞ (Tower Defense)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* HUD ‰ªãÈù¢ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-bar {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 1.2rem;
            font-weight: bold;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            border-bottom: 2px solid #666;
        }

        .stat-box span {
            color: #ffd700;
            font-size: 1.4rem;
        }

        #bottom-bar {
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
        }

        .tower-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid #ccc;
            border-radius: 10px;
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 110px;
        }

        .tower-btn:hover {
            transform: translateY(-5px);
            background: #fff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .tower-btn.selected {
            border-color: #00ff00;
            background: #e6ffe6;
            box-shadow: 0 0 20px #00ff00;
        }

        .tower-btn h4 {
            margin: 5px 0;
            color: #333;
            font-size: 1rem;
        }

        .tower-btn p {
            margin: 0;
            color: #d32f2f;
            font-weight: bold;
        }
        
        .tower-hp {
            font-size: 0.8rem;
            color: #666;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            text-align: center;
            border-radius: 20px;
            display: none;
            pointer-events: auto;
            border: 2px solid #ff4444;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            z-index: 10;
        }

        #game-over h1 {
            color: #ff4444;
            font-size: 3rem;
            margin-top: 0;
        }

        button.restart-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }

        button.restart-btn:hover {
            background: #ff6666;
        }

        .color-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-bottom: 5px;
            border: 1px solid #999;
        }
        
        /* Boss Ë≠¶ÂëäÊñáÂ≠ó */
        #boss-warning {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 0px black;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <div id="top-bar">
            <div class="stat-box">‚ù§Ô∏è ÁîüÂëΩ: <span id="lives-display">20</span></div>
            <div class="stat-box">üí∞ ÈáëÂπ£: <span id="money-display">1000</span></div>
            <div class="stat-box">üåä Ê≥¢Êï∏: <span id="wave-display">1</span></div>
            <div class="stat-box">üëæ Êïµ‰∫∫: <span id="enemy-count-display">0</span></div>
        </div>

        <div id="boss-warning">‚ö†Ô∏è Â∞èÈ≠îÁéãÂá∫Áèæ! ‚ö†Ô∏è</div>

        <div id="bottom-bar">
            <div class="tower-btn selected" onclick="selectTowerType('basic')" id="btn-basic">
                <div class="color-dot" style="background-color: #3498db;"></div>
                <h4>Ê©üÊßçÂ°î</h4>
                <p>$50</p>
                <span class="tower-hp">HP: 100</span>
            </div>
            <div class="tower-btn" onclick="selectTowerType('sniper')" id="btn-sniper">
                <div class="color-dot" style="background-color: #f1c40f;"></div>
                <h4>ÁãôÊìäÂ°î</h4>
                <p>$120</p>
                <span class="tower-hp">HP: 80</span>
            </div>
            <div class="tower-btn" onclick="selectTowerType('laser')" id="btn-laser">
                <div class="color-dot" style="background-color: #9b59b6;"></div>
                <h4>Èõ∑Â∞ÑÂ°î</h4>
                <p>$200</p>
                <span class="tower-hp">HP: 150</span>
            </div>
        </div>
    </div>

    <div id="game-over">
        <h1>ÈÅäÊà≤ÁµêÊùü</h1>
        <p>ÊúÄÁµÇÊ≥¢Êï∏: <span id="final-wave">1</span></p>
        <button class="restart-btn" onclick="restartGame()">ÈáçÊñ∞ÈñãÂßã</button>
    </div>
</div>

<script>
    // --- ÈÅäÊà≤Â∏∏Êï∏ ---
    const TILE_SIZE = 10;
    const GRID_WIDTH = 16;
    const GRID_HEIGHT = 10;
    
    // ÈÅäÊà≤ÁãÄÊÖã
    let state = {
        money: 1000,
        lives: 20,
        wave: 1,
        isGameOver: false,
        selectedTowerType: 'basic',
        enemies: [],
        towers: [],
        projectiles: [],
        particles: [],
        path: [],
        totalSpawnCount: 0 // Êñ∞Â¢ûÔºöÁ¥ØË®àÁî¢ÁîüÁöÑÊïµ‰∫∫Êï∏Èáè
    };

    // Ë™øÊï¥ÂæåÁöÑÊ≠¶Âô®Êï∏Êìö
    const TOWER_TYPES = {
        'basic': { price: 50, range: 35, damage: 40, color: 0x3498db, cooldown: 30, height: 8, maxHp: 100 },
        'sniper': { price: 120, range: 80, damage: 250, color: 0xf1c40f, cooldown: 90, height: 12, maxHp: 80 },
        'laser': { price: 200, range: 45, damage: 10, color: 0x9b59b6, cooldown: 5, height: 10, maxHp: 150 }
    };

    let scene, camera, renderer, raycaster, mouse;
    let gridMeshes = []; 
    // Âú∞ÂΩ¢È´òÂ∫¶Âúñ (r, c)
    let terrainHeights = [];

    // --- ÂàùÂßãÂåñ ---
    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Â§©Á©∫Ëóç
        scene.fog = new THREE.Fog(0x87CEEB, 50, 300);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 140, 120); 
        camera.lookAt(0, 0, 10);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0); 
        dirLight.position.set(60, 120, 40);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('pointerdown', onDocumentMouseDown, false);

        createMap();
        animate();
        startWave();
    }

    // --- Âú∞ÂúñÁîüÊàê (Âú∞ÂΩ¢ËàáË∑ØÂæë) ---
    // 0: ËçâÂú∞, 1: Ë∑ØÂæë
    const mapLayout = [
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0], // Âè≥ ->
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0], // ‰∏ã
        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0], // Â∑¶ <-
        [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // ‰∏ã
        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0], // Âè≥ ->
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0], // ‰∏ã
        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0], // Â∑¶ <-
        [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // ‰∏ã
        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]  // Âè≥ -> ÁµÇÈªû
    ];

    function createMap() {
        // 1. ÁîüÊàêÂú∞ÂΩ¢È´òÂ∫¶
        terrainHeights = [];
        for(let r=0; r<GRID_HEIGHT; r++) {
            let row = [];
            for(let c=0; c<GRID_WIDTH; c++) {
                let h = 0;
                
                const distFromCenter = Math.sqrt(Math.pow(r - GRID_HEIGHT/2, 2) + Math.pow(c - GRID_WIDTH/2, 2));
                
                if (mapLayout[r][c] === 1) {
                    h = 0;
                } else {
                    h = (Math.random() * 4) + 2; 
                    if (Math.random() < 0.1) h += 5; 
                }
                
                h = Math.round(h);
                row.push(h);
            }
            terrainHeights.push(row);
        }

        // 2. ÁîüÊàêË∑ØÂæëÁØÄÈªû (3DÂ∫ßÊ®ô)
        const pathIndices = [
            {r:1, c:0},  
            {r:1, c:14}, 
            {r:3, c:14}, 
            {r:3, c:1},  
            {r:5, c:1},  
            {r:5, c:14}, 
            {r:7, c:14}, 
            {r:7, c:1},  
            {r:9, c:1},  
            {r:9, c:15}  
        ];
        
        state.path = pathIndices.map(p => {
            const h = terrainHeights[p.r][p.c];
            return new THREE.Vector3(
                (p.c - GRID_WIDTH/2) * TILE_SIZE + TILE_SIZE/2,
                h + 3,
                (p.r - GRID_HEIGHT/2) * TILE_SIZE + TILE_SIZE/2
            );
        });

        // 3. Ê∏≤ÊüìÂú∞ÂΩ¢ÊñπÂ°ä
        const grassMat = new THREE.MeshLambertMaterial({ color: 0x7cb342 }); 
        const pathMat = new THREE.MeshLambertMaterial({ color: 0x757575 }); 
        const sideMat = new THREE.MeshLambertMaterial({ color: 0x5d4037 }); 

        for(let r=0; r<GRID_HEIGHT; r++) {
            for(let c=0; c<GRID_WIDTH; c++) {
                const type = mapLayout[r][c];
                const h = terrainHeights[r][c];
                
                const boxHeight = 40; 
                const geometry = new THREE.BoxGeometry(TILE_SIZE, boxHeight, TILE_SIZE);
                
                const materials = [
                    sideMat, sideMat, // x+, x-
                    type === 1 ? pathMat : grassMat, // y+ (top)
                    sideMat, // y- (bottom)
                    sideMat, sideMat // z+, z-
                ];

                const mesh = new THREE.Mesh(geometry, materials);
                
                mesh.position.set(
                    (c - GRID_WIDTH/2) * TILE_SIZE + TILE_SIZE/2,
                    h - boxHeight/2,
                    (r - GRID_HEIGHT/2) * TILE_SIZE + TILE_SIZE/2
                );
                
                mesh.receiveShadow = true;
                
                mesh.userData = {
                    type: type === 1 ? 'path' : 'grass',
                    gridX: c,
                    gridY: r,
                    height: h,
                    occupied: false
                };

                scene.add(mesh);
                gridMeshes.push(mesh);
            }
        }
        
        const planeGeo = new THREE.PlaneGeometry(500, 500);
        const planeMat = new THREE.MeshBasicMaterial({ color: 0x222222 }); 
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -30;
        scene.add(plane);
    }

    // --- Êïµ‰∫∫Á≥ªÁµ± (Âê´Ëµ∞Ë∑ØÂãïÁï´ & Ë£ùÁî≤) ---
    class Enemy {
        constructor(speed, hp, armor, color) {
            this.mesh = new THREE.Group();
            this.armor = armor || 0;
            this.maxHp = hp;
            this.hp = hp;
            
            // Ê†πÊìöË£ùÁî≤ÂÄºÊ±∫ÂÆöÈ´îÂûãÂ§ßÂ∞è
            const scale = 1 + (this.armor / 100); 
            this.mesh.scale.setScalar(scale);

            // 1. Ë∫´È´î
            const bodyGeo = new THREE.BoxGeometry(2.5, 3, 2.5);
            const bodyMat = new THREE.MeshPhongMaterial({ color: color });
            this.body = new THREE.Mesh(bodyGeo, bodyMat);
            this.body.position.y = 2.5; 
            this.body.castShadow = true;
            this.mesh.add(this.body);

            // 1.5 Ë£ùÁî≤Â§ñËßÄ
            if (this.armor > 0) {
                const armorMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
                
                // È†≠Áõî
                const helmetGeo = new THREE.BoxGeometry(2.7, 0.8, 2.7);
                const helmet = new THREE.Mesh(helmetGeo, armorMat);
                helmet.position.y = 4.1; 
                this.mesh.add(helmet);

                // ËÉ∏Áî≤
                if (this.armor >= 30) {
                    const chestGeo = new THREE.BoxGeometry(2.8, 1.5, 2.8);
                    const chest = new THREE.Mesh(chestGeo, armorMat);
                    chest.position.y = 3.0;
                    this.mesh.add(chest);
                }
            }

            // 2. ÈõôËÖ≥
            const legGeo = new THREE.CylinderGeometry(0.6, 0.6, 2.5);
            const legMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
            
            this.legL = new THREE.Mesh(legGeo, legMat);
            this.legL.position.set(-0.8, 1.25, 0); 
            this.mesh.add(this.legL);

            this.legR = new THREE.Mesh(legGeo, legMat);
            this.legR.position.set(0.8, 1.25, 0);
            this.mesh.add(this.legR);
            
            // ÁúºÁùõ
            const eyeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.2);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const eyeZ = 1.3 + (this.armor >= 30 ? 0.2 : 0); 
            
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(-0.6, 0.5, eyeZ);
            this.body.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(0.6, 0.5, eyeZ);
            this.body.add(eyeR);


            this.pathIndex = 0;
            this.progress = 0; 
            this.speed = speed;
            this.active = true;
            
            this.walkCycle = 0;

            // ÊîªÊìä AI
            this.state = 'MOVING';
            this.attackTarget = null;
            this.attackRange = 18; 
            this.attackDamage = 2 + Math.floor(this.armor / 10); 
            this.attackCooldown = 0;
            this.attackRate = 10; 

            this.mesh.position.copy(state.path[0]);
            scene.add(this.mesh);
        }

        update(delta) {
            if(!this.active) return;

            if(this.attackCooldown > 0) this.attackCooldown--;

            // Ëµ∞Ë∑ØÂãïÁï´
            if (this.state === 'MOVING') {
                const animSpeed = this.speed * 0.5 * (1 / this.mesh.scale.x);
                this.walkCycle += delta * animSpeed;
                
                this.legL.rotation.x = Math.sin(this.walkCycle) * 0.8;
                this.legR.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.8;
                this.body.position.y = 2.5 + Math.abs(Math.sin(this.walkCycle * 2)) * 0.2;
            } else {
                this.legL.rotation.x = THREE.MathUtils.lerp(this.legL.rotation.x, 0, 0.1);
                this.legR.rotation.x = THREE.MathUtils.lerp(this.legR.rotation.x, 0, 0.1);
            }

            // AI ÈÇèËºØ
            if (this.state === 'MOVING') {
                for(let tower of state.towers) {
                    if(tower.active && this.mesh.position.distanceTo(tower.mesh.position) < this.attackRange * this.mesh.scale.x) { 
                        this.state = 'ATTACKING';
                        this.attackTarget = tower;
                        break;
                    }
                }
            } else if (this.state === 'ATTACKING') {
                if(!this.attackTarget || !this.attackTarget.active) {
                    this.state = 'MOVING';
                    this.attackTarget = null;
                } else {
                    this.mesh.lookAt(this.attackTarget.mesh.position);
                    
                    if(this.attackCooldown <= 0) {
                        this.attackTarget.takeDamage(this.attackDamage);
                        this.attackCooldown = this.attackRate;
                        
                        this.body.rotation.x = 0.5;
                        setTimeout(() => { if(this.active) this.body.rotation.x = 0; }, 100);
                    }
                    return; 
                }
            }

            // ÁßªÂãïÈÇèËºØ
            const targetPos = state.path[this.pathIndex + 1];
            const startPos = state.path[this.pathIndex];
            
            if (!targetPos) {
                this.reachEnd();
                return;
            }

            const dist = startPos.distanceTo(targetPos);
            const step = this.speed * delta;
            this.progress += step / dist;

            if(this.progress >= 1) {
                this.progress = 0;
                this.pathIndex++;
                if(this.pathIndex >= state.path.length - 1) {
                    this.reachEnd();
                    return;
                }
            }

            const newPos = new THREE.Vector3().lerpVectors(
                state.path[this.pathIndex], 
                state.path[this.pathIndex+1], 
                this.progress
            );
            
            this.mesh.lookAt(targetPos); 
            this.mesh.position.copy(newPos);
        }

        takeDamage(amount) {
            const reduction = 100 / (100 + this.armor);
            const actualDamage = amount * reduction;

            this.hp -= actualDamage;
            
            const flashColor = this.armor > 0 ? 0xaaaaaa : 0xff0000;
            this.body.material.emissive.setHex(flashColor);
            setTimeout(() => {
                if(this.active) this.body.material.emissive.setHex(0x000000);
            }, 50);

            if(this.armor > 0 && Math.random() > 0.5) {
                createSparks(this.mesh.position);
            }

            if(this.hp <= 0) {
                this.die();
            }
        }

        die() {
            this.active = false;
            scene.remove(this.mesh);
            state.money += 20 + Math.floor(this.armor * 0.5);
            updateUI();
            createExplosion(this.mesh.position, this.body.material.color);
        }

        reachEnd() {
            this.active = false;
            scene.remove(this.mesh);
            state.lives--;
            updateUI();
            if(state.lives <= 0) gameOver();
        }
    }

    // --- Èò≤Á¶¶Â°îÁ≥ªÁµ± ---
    class Tower {
        constructor(mesh, typeName) {
            this.mesh = mesh;
            this.type = TOWER_TYPES[typeName];
            this.cooldown = 0;
            this.active = true;
            this.hp = this.type.maxHp;
            this.maxHp = this.type.maxHp;
            
            this.head = mesh.children[0]; 
        }

        update() {
            if(!this.active) return;
            if(this.cooldown > 0) this.cooldown--;

            let target = null;
            let minDist = this.type.range;

            state.enemies.forEach(enemy => {
                if(enemy.active) {
                    const dist = this.mesh.position.distanceTo(enemy.mesh.position);
                    if(dist < minDist) {
                        minDist = dist;
                        target = enemy;
                    }
                }
            });

            if(target) {
                this.head.lookAt(target.mesh.position);
                if(this.cooldown <= 0) {
                    this.shoot(target);
                    this.cooldown = this.type.cooldown;
                }
            }
        }

        shoot(target) {
            const startPos = new THREE.Vector3();
            this.head.getWorldPosition(startPos);
            const bullet = new Projectile(startPos, target, this.type.damage, this.type.color);
            state.projectiles.push(bullet);
        }

        takeDamage(amount) {
            this.hp -= amount;
            this.head.material.emissive.setHex(0xff3333);
            setTimeout(() => {
                if(this.active) this.head.material.emissive.setHex(0x000000);
            }, 100);

            if(this.hp <= 0) {
                this.destroy();
            }
        }

        destroy() {
            this.active = false;
            scene.remove(this.mesh);
            createExplosion(this.mesh.position, 0x555555);
            
            const pos = this.mesh.position;
            gridMeshes.forEach(grid => {
                if(Math.abs(grid.position.x - pos.x) < 1 && Math.abs(grid.position.z - pos.z) < 1) {
                    grid.userData.occupied = false;
                }
            });
        }
    }

    // --- ÊäïÂ∞ÑÁâ© ---
    class Projectile {
        constructor(startPos, targetEnemy, damage, color) {
            this.geometry = new THREE.BoxGeometry(0.8, 0.8, 2);
            this.material = new THREE.MeshBasicMaterial({ color: color });
            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.position.copy(startPos);
            
            this.target = targetEnemy;
            this.damage = damage;
            this.speed = 120;
            this.active = true;

            scene.add(this.mesh);
        }

        update(delta) {
            if(!this.active) return;
            
            if(!this.target.active) {
                this.destroy();
                return;
            }

            const targetPos = this.target.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
            this.mesh.lookAt(targetPos);
            
            const dist = this.mesh.position.distanceTo(targetPos);
            const moveDist = this.speed * delta;

            if(dist <= moveDist) {
                this.target.takeDamage(this.damage);
                this.destroy();
            } else {
                this.mesh.translateZ(moveDist);
            }
        }

        destroy() {
            this.active = false;
            scene.remove(this.mesh);
        }
    }

    // --- ÁâπÊïà ---
    class Particle {
        constructor(pos, color) {
            this.mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 1.2, 1.2),
                new THREE.MeshBasicMaterial({color: color, transparent: true})
            );
            this.mesh.position.copy(pos);
            
            this.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 25,
                (Math.random() - 0.5) * 25 + 10,
                (Math.random() - 0.5) * 25
            );
            this.life = 1.0; 
            scene.add(this.mesh);
        }
        
        update(delta) {
            this.velocity.y -= 40 * delta; 
            this.mesh.position.addScaledVector(this.velocity, delta);
            this.mesh.rotation.x += delta * 10;
            
            this.life -= delta * 2.5;
            this.mesh.scale.setScalar(this.life);
            this.mesh.material.opacity = this.life;
        }
        
        isDead() { return this.life <= 0; }
        dispose() { scene.remove(this.mesh); }
    }

    function createExplosion(pos, color) {
        for(let i=0; i<8; i++) {
            state.particles.push(new Particle(pos, color));
        }
    }

    function createSparks(pos) {
        for(let i=0; i<3; i++) {
            const spark = new Particle(pos, 0xffff00); 
            spark.mesh.scale.setScalar(0.5); 
            spark.velocity.multiplyScalar(1.5); 
            state.particles.push(spark);
        }
    }

    // --- ÈÅäÊà≤Âæ™Áí∞ ---
    let waveTimer = 0;
    let enemiesToSpawn = 0;
    let spawnDelay = 0;

    function startWave() {
        state.wave++;
        enemiesToSpawn = 5 + Math.floor(state.wave * 2);
        updateUI();
    }

    function spawnEnemyLogic(delta) {
        if(enemiesToSpawn > 0) {
            spawnDelay -= delta;
            if(spawnDelay <= 0) {
                // Â¢ûÂä†Â∑≤ÁîüÊàêÁ∏ΩÊï∏
                state.totalSpawnCount++;
                
                // Âü∫Á§éÊï∏ÂÄº
                let hp = 50 + (state.wave * 25);
                let armor = Math.max(0, (state.wave - 1) * 10);
                let speed = 20 + (state.wave * 1.5);
                let color = new THREE.Color().setHSL((state.wave * 0.15) % 1, 0.8, 0.5);

                // Â∞èÈ≠îÁéãÈÇèËºØ: ÊØè 10 ÈöªÂá∫Áèæ 1 Èöª
                if (state.totalSpawnCount % 10 === 0) {
                    hp *= 5; // Ë°ÄÈáè 5 ÂÄç
                    armor += 80; // Ë£ùÁî≤ + 80 (ÈÄôÊúÉÂ∞éËá¥È´îÂûã scale Â¢ûÂä† 0.8ÔºåËÆäÂæóÂæàÂ§ß)
                    speed *= 0.7; // Â∑®Â§ßÂåñÂæåËµ∞ÂæóÊÖ¢
                    color = 0xff0000; // Á¥ÖËâ≤
                    
                    // È°ØÁ§∫ Boss Ë≠¶Âëä
                    const warning = document.getElementById('boss-warning');
                    warning.style.opacity = 1;
                    setTimeout(() => warning.style.opacity = 0, 2000);
                } else {
                    // ÊôÆÈÄöÊïµ‰∫∫ÈÄüÂ∫¶ÂèóË£ùÁî≤Á®çÂæÆÂΩ±Èüø
                    speed = Math.max(10, speed - (armor * 0.1)); 
                }

                state.enemies.push(new Enemy(speed, hp, armor, color));
                enemiesToSpawn--;
                spawnDelay = 0.8; 
                
                document.getElementById('enemy-count-display').innerText = state.enemies.filter(e => e.active).length + enemiesToSpawn;
            }
        } else if (state.enemies.filter(e => e.active).length === 0) {
            waveTimer += delta;
            if(waveTimer > 2) { 
                startWave();
                waveTimer = 0;
            }
        }
        document.getElementById('enemy-count-display').innerText = state.enemies.filter(e => e.active).length + enemiesToSpawn;
    }

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const delta = Math.min(clock.getDelta(), 0.1); 

        if(!state.isGameOver) {
            spawnEnemyLogic(delta);

            state.enemies.forEach(e => e.update(delta));
            state.enemies = state.enemies.filter(e => e.active);

            state.towers.forEach(t => t.update());
            state.towers = state.towers.filter(t => t.active);

            state.projectiles.forEach(p => p.update(delta));
            state.projectiles = state.projectiles.filter(p => p.active);
            
            state.particles.forEach(p => p.update(delta));
            for(let i = state.particles.length - 1; i >= 0; i--) {
                if(state.particles[i].isDead()) {
                    state.particles[i].dispose();
                    state.particles.splice(i, 1);
                }
            }
        }

        renderer.render(scene, camera);
    }

    // --- ‰∫§‰∫í ---
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function selectTowerType(type) {
        state.selectedTowerType = type;
        document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
        document.getElementById('btn-' + type).classList.add('selected');
    }

    function onDocumentMouseDown(event) {
        if(state.isGameOver) return;
        if(event.target.closest('.tower-btn')) return;

        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(gridMeshes);

        if (intersects.length > 0) {
            const object = intersects[0].object;
            const data = object.userData;

            if (data.type === 'grass' && !data.occupied) {
                buildTower(object);
            }
        }
    }

    function buildTower(gridMesh) {
        const typeConfig = TOWER_TYPES[state.selectedTowerType];
        const terrainH = gridMesh.userData.height;

        if(state.money >= typeConfig.price) {
            state.money -= typeConfig.price;
            updateUI();

            const baseGeo = new THREE.BoxGeometry(TILE_SIZE * 0.8, 2, TILE_SIZE * 0.8);
            const baseMat = new THREE.MeshPhongMaterial({ color: 0xdddddd }); 
            const baseMesh = new THREE.Mesh(baseGeo, baseMat);
            
            const headHeight = typeConfig.height;
            const headGeo = new THREE.CylinderGeometry(2, 3, headHeight, 8);
            const headMat = new THREE.MeshPhongMaterial({ color: typeConfig.color });
            const headMesh = new THREE.Mesh(headGeo, headMat);
            headMesh.position.y = headHeight/2 + 1; 
            
            const barrelGeo = new THREE.CylinderGeometry(0.8, 0.8, 6);
            const barrelMesh = new THREE.Mesh(barrelGeo, new THREE.MeshPhongMaterial({color: 0x555555}));
            barrelMesh.rotation.x = Math.PI / 2;
            barrelMesh.position.z = 2;
            barrelMesh.position.y = 2;
            headMesh.add(barrelMesh);

            baseMesh.add(headMesh);

            baseMesh.position.set(gridMesh.position.x, terrainH + 1, gridMesh.position.z);
            scene.add(baseMesh);

            createExplosion(baseMesh.position, typeConfig.color);

            gridMesh.userData.occupied = true;
            state.towers.push(new Tower(baseMesh, state.selectedTowerType));
        } else {
            const el = document.getElementById('money-display');
            el.style.color = 'red';
            setTimeout(() => el.style.color = '#ffd700', 500);
        }
    }

    function updateUI() {
        document.getElementById('lives-display').innerText = state.lives;
        document.getElementById('money-display').innerText = state.money;
        document.getElementById('wave-display').innerText = state.wave;
    }

    function gameOver() {
        state.isGameOver = true;
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('final-wave').innerText = state.wave;
    }

    window.restartGame = function() {
        location.reload();
    };

    init();
</script>
</body>
</html>
